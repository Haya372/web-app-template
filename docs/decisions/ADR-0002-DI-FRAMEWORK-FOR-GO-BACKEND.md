# ADR-0002: DI Framework for go-backend

Date: 2026-02-15  
Status: Accepted

---

## Context
go-backend の依存関係構築（Dependency Injection）において、DI フレームワークの選定が必要となった。

### Background
- go-backend では、ハンドラ・ユースケース・リポジトリなど複数レイヤーの依存を組み立てる必要がある。
- チーム開発を前提とし、実装変更時のレビュー容易性とマージ容易性を重視する。
- 起動時初期化の責務を明確化し、実行時の不確実性を減らしたい。

### Scope
- 対象: go-backend におけるアプリケーションの依存解決方式。
- 対象外: Web フレームワーク選定、ORM 選定、インフラ構成そのもの。

### Constraints
- コンストラクタ注入を基本とし、依存の見通しを保つこと。
- 依存関係の変更が発生しても、レビューとマージの負荷を過度に増やさないこと。
- 可能な限り実行時エラーよりもビルド時検知を優先すること。

## Decision
go-backend の DI フレームワークとして **wire** を採用する。

運用ルール:
- 依存解決は `wire` によるコード生成で構成する。
- 生成対象以外のレイヤーではサービスロケータ的な依存取得を行わない。
- 依存の追加・変更時は `wire` 定義を更新し、生成コードを最新化する。

## Options

### Option A: wire
- 概要
  - コンパイル時に DI コードを生成する方式。
- Pros
  - 依存解決が明示的なコードとして生成され、レビューしやすい。
  - 実行時リフレクションに依存せず、ビルド時に問題を検知しやすい。
  - 依存変更時の差分が追いやすく、競合解決の判断がしやすい。
- Cons
  - 生成コードの更新手順を運用に含める必要がある。
  - 定義ファイルの作法をチームで共有する必要がある。
- 想定ユースケース / 制約
  - 依存関係の明示性とマージ容易性を重視するバックエンド。

### Option B: dig
- 概要
  - リフレクションベースで依存を実行時に解決するコンテナ。
- Pros
  - 導入が比較的容易で、定義の記述量を抑えやすい。
  - 柔軟に依存を登録できる。
- Cons
  - 実行時解決のため、問題発覚が起動時に寄りやすい。
  - 依存の追跡がコード生成方式より読み取りづらい場合がある。
- 想定ユースケース / 制約
  - 高い動的性を優先し、実行時構成の柔軟性が重要なケース。

### Option C: fx
- 概要
  - `dig` を基盤とし、ライフサイクル管理やモジュール化を提供するフレームワーク。
- Pros
  - 起動・停止フックなどアプリケーションライフサイクルを統一管理しやすい。
  - 大規模構成でモジュール分割しやすい。
- Cons
  - go-backend の現状スコープに対しては機能が過剰になりうる。
  - 学習コストと運用ルールが増える。
- 想定ユースケース / 制約
  - 複雑なライフサイクル制御やモジュール運用が主目的のケース。

### Option D: 自前実装
- 概要
  - DI コンテナを使わず、初期化コードを手動で実装する。
- Pros
  - 外部依存を増やさず、構成を完全に制御できる。
  - 小規模ではシンプルに始められる。
- Cons
  - 依存が増えるにつれて初期化コードが肥大化しやすい。
  - 変更時の影響範囲把握と保守コストが高くなる。
- 想定ユースケース / 制約
  - 依存数が少なく、構成の変化が限定的なケース。

## Rationale
最終的な判断軸は以下。

- 依存関係の可視性
- 変更差分の追跡しやすさ
- マージコンフリクト対応コスト

`dig` と `fx` は柔軟性が高い一方、依存解決が実行時評価になりやすく、変更時の追跡とレビューで追加認知負荷が発生しやすい。自前実装は初期コストを抑えられるが、依存が増加すると初期化コードの集中化による保守負荷が増える。

`wire` は依存解決を生成コードとして明示できるため、変更差分が明確になり、チーム開発でのコンフリクト解決コストを下げやすい。また、設定不備はビルド時に検知しやすく、実行時まで問題を持ち越しにくい。さらに、生成コードは Git 管理対象外（`.gitignore`）として扱う運用により、生成物由来のコンフリクトを最小化できる。以上より、go-backend では `wire` を採用する。

## Consequences
- Positive
  - 依存関係がコードとして可視化され、レビューしやすくなる。
  - 依存変更時の差分が明確で、コンフリクト時の解決判断がしやすい。
  - 設定不備をビルド時に検知しやすい。
  - 生成コードを Git 管理対象外にすることで、生成物によるコンフリクトを最小限にできる。

- Negative
  - 生成手順の運用漏れがあると差分不整合が発生しうる。
  - 生成コードを含むため、PR 上の差分量が増える場合がある。

- Migration / Follow-up
  - `go-backend` 側に `wire` 実行手順（例: Make ターゲット）を明文化する。
  - `wire` の生成コードを `.gitignore` に追加し、生成物を Git 管理対象外とする運用を徹底する。
  - 依存追加時のレビュー観点（provider 定義、生成更新確認）を開発フローに含める。

## References
- wire: https://github.com/google/wire
- dig: https://github.com/uber-go/dig
- fx: https://github.com/uber-go/fx
