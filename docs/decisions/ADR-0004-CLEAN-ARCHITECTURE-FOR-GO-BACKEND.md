# ADR-0004: Clean Architecture for go-backend

Date: 2026-02-15  
Status: Accepted

---

## Context
ADR-0001 では Echo 採用時の Follow-up として「go-backend に実装規約（ハンドラ責務、ミドルウェア配置、エラーハンドリング）を定義する」ことを課題として残した。本 ADR は、その課題に対してアーキテクチャ境界と依存ルールを明文化するための決定である。

### Background
- `go-backend` では今後、HTTP API のエンドポイントや外部連携が継続的に増える想定である。
- Web フレームワーク（Echo）と DI（wire）は採用済みだが、ADR-0001 時点では責務分離の原則のみで、レイヤー責務と依存方向の具体ルールまでは定義していない。
- チーム開発で、レビュー時に依存関係の妥当性を判断しやすい構造が必要である。

### Scope
- 対象: `go-backend` のアプリケーション構造（レイヤー分割、依存方向、実装責務）。
- 対象外: Web フレームワークや DI ツール自体の再選定、DB 製品の選定。

### Constraints
- ビジネスルールはフレームワークや永続化手段の詳細から独立させる。
- 依存関係は循環させない。
- ユースケース層はテスト容易性を優先し、外部 I/O を直接扱わない。

## Decision
go-backend のアーキテクチャとして **Clean Architecture** を採用する。

これは ADR-0001 の Follow-up で求めた実装規約を具体化する決定として位置づける。

運用ルール:
- 依存方向は外側から内側のみ（`interface adapter -> usecase -> domain`）とする。
- `domain` はビジネスルールとエンティティを保持し、外部パッケージ依存を最小化する。
- `usecase` はアプリケーション固有の業務フローを実装し、外部連携は interface（port）経由で扱う。
- `interface adapter`（HTTP handler、repository 実装、外部 API client 実装）は入出力変換を担当し、業務判断を持たない。
- Echo 依存は HTTP ハンドラ層に閉じ込め、`usecase`/`domain` へ漏らさない。
- wire は composition root（`cmd/` など起動境界）でのみ使用し、各レイヤーに DI コンテナを持ち込まない。

## Options

### Option A: Clean Architecture
- 概要
  - レイヤーごとに責務を分離し、依存方向を内向きに統制する。
- Pros
  - ビジネスルールを技術選択から分離しやすく、変更耐性が高い。
  - ユースケース単位でテストしやすい。
  - HTTP/gRPC など入口追加時もユースケース再利用がしやすい。
- Cons
  - 初期段階で層分割と命名規約の設計コストが発生する。
  - 小規模機能では実装量が増えたように見える場合がある。
- 想定ユースケース / 制約
  - 中長期で機能追加・外部連携増加が見込まれる API バックエンド。

### Option B: Layered Architecture（依存方向の厳格制約なし）
- 概要
  - controller/service/repository の層を持つが、依存逆転を必須にしない。
- Pros
  - 導入時の理解が容易で、初期開発を素早く進めやすい。
  - シンプルな CRUD 中心の実装では十分機能する。
- Cons
  - フレームワーク・DB 都合が service 層へ浸透しやすく、変更時の影響範囲が拡大しやすい。
  - 境界が曖昧になり、ユースケース単位の再利用性が下がりやすい。
- 想定ユースケース / 制約
  - 短期・小規模で構造的変更が少ないプロジェクト。

### Option C: Feature-first（機能単位の縦切り）
- 概要
  - 機能ごとに handler/usecase/repository を同居させる構成。
- Pros
  - 機能追加時の探索コストが低く、変更対象が追いやすい。
  - チームの並行開発時にファイル衝突を減らしやすい。
- Cons
  - 共通ルールが弱いと、機能ごとに設計品質がばらつきやすい。
  - 依存方向を統制しない場合、結局密結合化しやすい。
- 想定ユースケース / 制約
  - 強い規約やlintで境界管理できる体制がある場合に有効。

## Rationale
最終判断で重視した軸は以下。

- 変更容易性（機能追加や技術差し替え時の影響範囲）
- テスト容易性（ユースケースを単体検証できること）
- 依存関係の明確さ（レビューしやすい構造）

単純な layered 構成は短期生産性に利点がある一方、長期では外部都合が業務ロジックに侵入しやすい。feature-first は探索性に優れるが、依存規律がなければ品質がばらつく。go-backend は今後の拡張性と保守性を優先するため、依存方向と責務分離を明確化できる Clean Architecture を採用する。

また、既存の Echo 採用方針（ADR-0001）および wire 採用方針（ADR-0002）とも整合する。Echo 依存を adapter 層に閉じ込め、wire を composition root に限定することで、ビジネスルールの独立性を維持できる。
加えて、ADR-0001 で未確定だった「どこまでをハンドラ責務とし、どこからを業務ロジックとするか」の境界を、この ADR で明示できる。

## Consequences
- Positive
  - 技術要素（Web/DB）と業務ロジックの境界が明確になり、変更時の影響を局所化しやすい。
  - ユースケースのテストを外部依存なしで実行しやすくなる。
  - 将来的な gRPC 追加や repository 実装差し替え時の再利用性が上がる。

- Negative
  - 初期実装で interface 定義や変換コードが増え、学習コストが発生する。
  - 規約が曖昧だと「名前だけ Clean Architecture」になるリスクがある。

- Migration / Follow-up
  - `go-backend` にレイヤー責務と依存方向の実装規約を追加する。
  - PR レビュー観点に「Echo 依存の漏れ」「usecase からの直接 I/O」「循環依存」を明記する。
  - ユースケース単位のテストテンプレート（mock 方針含む）を整備する。

## References
- [ADR-0001: Web Framework for go-backend](./ADR-0001-WEB-FRAMEWORK.md)
